"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAllRepositories = exports.listAppHostingConnections = exports.getOrCreateRepository = exports.getOrCreateConnection = exports.createConnection = exports.ensureSecretManagerAdminGrant = exports.getOrCreateOauthConnection = exports.linkGitHubRepository = exports.generateRepositoryId = exports.extractRepoSlugFromUri = exports.parseConnectionName = void 0;
const clc = require("colorette");
const devConnect = require("../gcp/devConnect");
const rm = require("../gcp/resourceManager");
const poller = require("../operation-poller");
const utils = require("../utils");
const error_1 = require("../error");
const prompt_1 = require("../prompt");
const getProjectNumber_1 = require("../getProjectNumber");
const api_1 = require("../api");
const fuzzy = require("fuzzy");
const inquirer = require("inquirer");
const APPHOSTING_CONN_PATTERN = /.+\/apphosting-github-conn-.+$/;
const APPHOSTING_OAUTH_CONN_NAME = "apphosting-github-oauth";
const CONNECTION_NAME_REGEX = /^projects\/(?<projectId>[^\/]+)\/locations\/(?<location>[^\/]+)\/connections\/(?<id>[^\/]+)$/;
function parseConnectionName(name) {
    const match = CONNECTION_NAME_REGEX.exec(name);
    if (!match || typeof match.groups === undefined) {
        return;
    }
    const { projectId, location, id } = match.groups;
    return {
        projectId,
        location,
        id,
    };
}
exports.parseConnectionName = parseConnectionName;
const devConnectPollerOptions = {
    apiOrigin: (0, api_1.developerConnectOrigin)(),
    apiVersion: "v1",
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
function extractRepoSlugFromUri(cloneUri) {
    const match = /github.com\/(.+).git/.exec(cloneUri);
    if (!match) {
        return undefined;
    }
    return match[1];
}
exports.extractRepoSlugFromUri = extractRepoSlugFromUri;
function generateRepositoryId(remoteUri) {
    var _a;
    return (_a = extractRepoSlugFromUri(remoteUri)) === null || _a === void 0 ? void 0 : _a.replaceAll("/", "-");
}
exports.generateRepositoryId = generateRepositoryId;
function generateConnectionId() {
    const randomHash = Math.random().toString(36).slice(6);
    return `apphosting-github-conn-${randomHash}`;
}
const ADD_CONN_CHOICE = "@ADD_CONN";
async function linkGitHubRepository(projectId, location) {
    var _a, _b;
    utils.logBullet(clc.bold(`${clc.yellow("===")} Set up a GitHub connection`));
    const oauthConn = await getOrCreateOauthConnection(projectId, location);
    const existingConns = await listAppHostingConnections(projectId);
    if (existingConns.length === 0) {
        existingConns.push(await createFullyInstalledConnection(projectId, location, generateConnectionId(), oauthConn));
    }
    let repoCloneUri;
    let connection;
    do {
        if (repoCloneUri === ADD_CONN_CHOICE) {
            existingConns.push(await createFullyInstalledConnection(projectId, location, generateConnectionId(), oauthConn, true));
        }
        const selection = await promptCloneUri(projectId, existingConns);
        repoCloneUri = selection.cloneUri;
        connection = selection.connection;
    } while (repoCloneUri === ADD_CONN_CHOICE);
    const { id: connectionId } = parseConnectionName(connection.name);
    await getOrCreateConnection(projectId, location, connectionId, {
        authorizerCredential: (_a = connection.githubConfig) === null || _a === void 0 ? void 0 : _a.authorizerCredential,
        appInstallationId: (_b = connection.githubConfig) === null || _b === void 0 ? void 0 : _b.appInstallationId,
    });
    const repo = await getOrCreateRepository(projectId, location, connectionId, repoCloneUri);
    utils.logSuccess(`Successfully linked GitHub repository at remote URI`);
    utils.logSuccess(`\t${repo.cloneUri}`);
    return repo;
}
exports.linkGitHubRepository = linkGitHubRepository;
async function createFullyInstalledConnection(projectId, location, connectionId, oauthConn, withNewInstallation = false) {
    var _a, _b;
    let conn = await createConnection(projectId, location, connectionId, {
        appInstallationId: withNewInstallation ? undefined : (_a = oauthConn.githubConfig) === null || _a === void 0 ? void 0 : _a.appInstallationId,
        authorizerCredential: (_b = oauthConn.githubConfig) === null || _b === void 0 ? void 0 : _b.authorizerCredential,
    });
    while (conn.installationState.stage !== "COMPLETE") {
        utils.logBullet("Install the Firebase GitHub app to enable access to GitHub repositories");
        const targetUri = conn.installationState.actionUri.replace("install_v2", "direct_install_v2");
        utils.logBullet(targetUri);
        await utils.openInBrowser(targetUri);
        await (0, prompt_1.promptOnce)({
            type: "input",
            message: "Press Enter once you have installed or configured the Firebase GitHub app to access your GitHub repo.",
        });
        conn = await devConnect.getConnection(projectId, location, connectionId);
    }
    return conn;
}
async function getOrCreateOauthConnection(projectId, location) {
    let conn;
    try {
        conn = await devConnect.getConnection(projectId, location, APPHOSTING_OAUTH_CONN_NAME);
    }
    catch (err) {
        if (err.status === 404) {
            await ensureSecretManagerAdminGrant(projectId);
            conn = await createConnection(projectId, location, APPHOSTING_OAUTH_CONN_NAME);
        }
        else {
            throw err;
        }
    }
    while (conn.installationState.stage === "PENDING_USER_OAUTH") {
        utils.logBullet("You must authorize the Firebase GitHub app.");
        utils.logBullet("Sign in to GitHub and authorize Firebase GitHub app:");
        const { url, cleanup } = await utils.openInBrowserPopup(conn.installationState.actionUri, "Authorize the GitHub app");
        utils.logBullet(`\t${url}`);
        await (0, prompt_1.promptOnce)({
            type: "input",
            message: "Press Enter once you have authorized the app",
        });
        cleanup();
        const { projectId, location, id } = parseConnectionName(conn.name);
        conn = await devConnect.getConnection(projectId, location, id);
    }
    return conn;
}
exports.getOrCreateOauthConnection = getOrCreateOauthConnection;
async function promptCloneUri(projectId, connections) {
    const { cloneUris, cloneUriToConnection } = await fetchAllRepositories(projectId, connections);
    const cloneUri = await (0, prompt_1.promptOnce)({
        type: "autocomplete",
        name: "cloneUri",
        message: "Which of the following repositories would you like to deploy?",
        source: (_, input = "") => {
            return new Promise((resolve) => resolve([
                new inquirer.Separator(),
                {
                    name: "Missing a repo? Select this option to configure your GitHub connection settings",
                    value: ADD_CONN_CHOICE,
                },
                new inquirer.Separator(),
                ...fuzzy
                    .filter(input, cloneUris, {
                    extract: (uri) => extractRepoSlugFromUri(uri) || "",
                })
                    .map((result) => {
                    return {
                        name: extractRepoSlugFromUri(result.original) || "",
                        value: result.original,
                    };
                }),
            ]));
        },
    });
    return { cloneUri, connection: cloneUriToConnection[cloneUri] };
}
async function ensureSecretManagerAdminGrant(projectId) {
    const projectNumber = await (0, getProjectNumber_1.getProjectNumber)({ projectId });
    const dcsaEmail = devConnect.serviceAgentEmail(projectNumber);
    const alreadyGranted = await rm.serviceAccountHasRoles(projectId, dcsaEmail, ["roles/secretmanager.admin"], true);
    if (alreadyGranted) {
        utils.logBullet("secret manager admin role already granted");
        return;
    }
    utils.logBullet("To create a new GitHub connection, Secret Manager Admin role (roles/secretmanager.admin) is required on the Developer Connect Service Agent.");
    const grant = await (0, prompt_1.promptOnce)({
        type: "confirm",
        message: "Grant the required role to the Developer Connect Service Agent?",
    });
    if (!grant) {
        utils.logBullet("You, or your project administrator, should run the following command to grant the required role:\n\n" +
            "You, or your project adminstrator, can run the following command to grant the required role manually:\n\n" +
            `\tgcloud projects add-iam-policy-binding ${projectId} \\\n` +
            `\t  --member="serviceAccount:${dcsaEmail} \\\n` +
            `\t  --role="roles/secretmanager.admin\n`);
        throw new error_1.FirebaseError("Insufficient IAM permissions to create a new connection to GitHub");
    }
    try {
        await rm.addServiceAccountToRoles(projectId, dcsaEmail, ["roles/secretmanager.admin"], true);
    }
    catch (e) {
        if ((e === null || e === void 0 ? void 0 : e.code) === 400 || (e === null || e === void 0 ? void 0 : e.status) === 400) {
            await devConnect.generateP4SA(projectNumber);
            await rm.addServiceAccountToRoles(projectId, dcsaEmail, ["roles/secretmanager.admin"], true);
        }
        else {
            throw e;
        }
    }
    utils.logSuccess("Successfully granted the required role to the Developer Connect Service Agent!");
}
exports.ensureSecretManagerAdminGrant = ensureSecretManagerAdminGrant;
async function createConnection(projectId, location, connectionId, githubConfig) {
    const op = await devConnect.createConnection(projectId, location, connectionId, githubConfig);
    const conn = await poller.pollOperation(Object.assign(Object.assign({}, devConnectPollerOptions), { pollerName: `create-${location}-${connectionId}`, operationResourceName: op.name }));
    return conn;
}
exports.createConnection = createConnection;
async function getOrCreateConnection(projectId, location, connectionId, githubConfig) {
    let conn;
    try {
        conn = await devConnect.getConnection(projectId, location, connectionId);
    }
    catch (err) {
        if (err.status === 404) {
            utils.logBullet("creating connection");
            conn = await createConnection(projectId, location, connectionId, githubConfig);
        }
        else {
            throw err;
        }
    }
    return conn;
}
exports.getOrCreateConnection = getOrCreateConnection;
async function getOrCreateRepository(projectId, location, connectionId, cloneUri) {
    const repositoryId = generateRepositoryId(cloneUri);
    if (!repositoryId) {
        throw new error_1.FirebaseError(`Failed to generate repositoryId for URI "${cloneUri}".`);
    }
    let repo;
    try {
        repo = await devConnect.getGitRepositoryLink(projectId, location, connectionId, repositoryId);
    }
    catch (err) {
        if (err.status === 404) {
            const op = await devConnect.createGitRepositoryLink(projectId, location, connectionId, repositoryId, cloneUri);
            repo = await poller.pollOperation(Object.assign(Object.assign({}, devConnectPollerOptions), { pollerName: `create-${location}-${connectionId}-${repositoryId}`, operationResourceName: op.name }));
        }
        else {
            throw err;
        }
    }
    return repo;
}
exports.getOrCreateRepository = getOrCreateRepository;
async function listAppHostingConnections(projectId) {
    const conns = await devConnect.listAllConnections(projectId, "-");
    return conns.filter((conn) => APPHOSTING_CONN_PATTERN.test(conn.name) &&
        conn.installationState.stage === "COMPLETE" &&
        !conn.disabled);
}
exports.listAppHostingConnections = listAppHostingConnections;
async function fetchAllRepositories(projectId, connections) {
    const cloneUriToConnection = {};
    for (const conn of connections) {
        const { location, id } = parseConnectionName(conn.name);
        const connectionRepos = await devConnect.listAllLinkableGitRepositories(projectId, location, id);
        connectionRepos.forEach((repo) => {
            cloneUriToConnection[repo.cloneUri] = conn;
        });
    }
    return { cloneUris: Object.keys(cloneUriToConnection), cloneUriToConnection };
}
exports.fetchAllRepositories = fetchAllRepositories;
