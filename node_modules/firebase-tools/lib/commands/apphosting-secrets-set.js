"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.command = void 0;
const tty = require("tty");
const clc = require("colorette");
const path_1 = require("path");
const command_1 = require("../command");
const projectUtils_1 = require("../projectUtils");
const requireAuth_1 = require("../requireAuth");
const fs = require("fs");
const gcsm = require("../gcp/secretManager");
const apphosting = require("../gcp/apphosting");
const requirePermissions_1 = require("../requirePermissions");
const prompt_1 = require("../prompt");
const secrets = require("../apphosting/secrets");
const dialogs = require("../apphosting/secrets/dialogs");
const config = require("../apphosting/config");
const utils_1 = require("../utils");
exports.command = new command_1.Command("apphosting:secrets:set <secretName>")
    .description("grant service accounts permissions to the provided secret")
    .option("-l, --location <location>", "optional location to retrict secret replication")
    .withForce("Automatically create a secret, grant permissions, and add to YAML.")
    .before(requireAuth_1.requireAuth)
    .before(gcsm.ensureApi)
    .before(apphosting.ensureApiEnabled)
    .before(requirePermissions_1.requirePermissions, [
    "secretmanager.secrets.create",
    "secretmanager.secrets.get",
    "secretmanager.secrets.update",
    "secretmanager.versions.add",
    "secretmanager.secrets.getIamPolicy",
    "secretmanager.secrets.setIamPolicy",
])
    .option("--data-file <dataFile>", 'File path from which to read secret data. Set to "-" to read the secret data from stdin.')
    .action(async (secretName, options) => {
    var _a;
    const howToAccess = `You can access the contents of the secret's latest value with ${clc.bold(`firebase apphosting:secrets:access ${secretName}`)}`;
    const grantAccess = `To use this secret in your backend, you must grant access. You can do so in the future with ${clc.bold("firebase apphosting:secrets:grantAccess")}`;
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const projectNumber = await (0, projectUtils_1.needProjectNumber)(options);
    const created = await secrets.upsertSecret(projectId, secretName, options.location);
    if (created === null) {
        return;
    }
    let secretValue;
    if ((!options.dataFile || options.dataFile === "-") && tty.isatty(0)) {
        secretValue = await (0, prompt_1.promptOnce)({
            type: "password",
            message: `Enter a value for ${secretName}`,
        });
    }
    else {
        let dataFile = 0;
        if (options.dataFile && options.dataFile !== "-") {
            dataFile = options.dataFile;
        }
        secretValue = fs.readFileSync(dataFile, "utf-8");
    }
    if (created) {
        (0, utils_1.logSuccess)(`Created new secret projects/${projectId}/secrets/${secretName}`);
    }
    const version = await gcsm.addVersion(projectId, secretName, secretValue);
    (0, utils_1.logSuccess)(`Created new secret version ${gcsm.toSecretVersionResourceName(version)}`);
    (0, utils_1.logSuccess)(howToAccess);
    if (!created) {
        (0, utils_1.logWarning)(grantAccess);
        return;
    }
    const accounts = await dialogs.selectBackendServiceAccounts(projectNumber, projectId, options);
    if (!accounts.buildServiceAccounts.length && !accounts.runServiceAccounts.length) {
        (0, utils_1.logWarning)(grantAccess);
    }
    else {
        await secrets.grantSecretAccess(projectId, secretName, accounts);
    }
    let path = config.yamlPath(process.cwd());
    let yaml = {};
    if (path) {
        yaml = config.load(path);
        if ((_a = yaml.env) === null || _a === void 0 ? void 0 : _a.find((env) => env.variable === secretName)) {
            return;
        }
    }
    const addToYaml = await (0, prompt_1.confirm)({
        message: "Would you like to add this secret to apphosting.yaml?",
        default: true,
    });
    if (!addToYaml) {
        return;
    }
    if (!path) {
        path = await (0, prompt_1.promptOnce)({
            message: "It looks like you don't have an apphosting.yaml yet. Where would you like to store it?",
            default: process.cwd(),
        });
        path = (0, path_1.join)(path, "apphosting.yaml");
    }
    const envName = await dialogs.envVarForSecret(secretName);
    yaml.env = yaml.env || [];
    yaml.env.push({
        variable: envName,
        secret: secretName,
    });
    config.store(path, yaml);
});
